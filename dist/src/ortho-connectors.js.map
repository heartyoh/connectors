{"version":3,"file":"ortho-connectors.js","sourceRoot":"","sources":["../../src/ortho-connectors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Orthogonal Connector Router\n *   - Given two rectangles and their connection points, returns the path for an orthogonal connector.\n *\n * https://jose.page\n * 2020\n */\n\ntype BasicCardinalPoint = 'n' | 'e' | 's' | 'w'\ntype Direction = 'v' | 'h'\ntype Side = 'top' | 'right' | 'bottom' | 'left'\ntype BendDirection = BasicCardinalPoint | 'unknown' | 'none'\n\n/**\n * A point in space\n */\ninterface Point {\n  x: number\n  y: number\n}\n\n/**\n * A size tuple\n */\ninterface Size {\n  width: number\n  height: number\n}\n\n/**\n * A line between two points\n */\ninterface Line {\n  a: Point\n  b: Point\n}\n\n/**\n * Represents a Rectangle by location and size\n */\ninterface Rect extends Size {\n  left: number\n  top: number\n}\n\n/**\n * Represents a connection point on a routing request\n */\ninterface ConnectorPoint {\n  shape: Rect\n  side: Side\n  distance: number\n}\n\n/**\n * Byproduct data emitted by the routing algorithm\n */\ninterface OrthogonalConnectorByproduct {\n  hRulers: number[]\n  vRulers: number[]\n  spots: Point[]\n  grid: Rectangle[]\n  connections: Line[]\n}\n\n/**\n * Routing request data\n */\ninterface OrthogonalConnectorOpts {\n  pointA: ConnectorPoint\n  pointB: ConnectorPoint\n  shapeMargin: number\n  globalBoundsMargin: number\n  globalBounds: Rect\n}\n\n/**\n * Utility Point creator\n * @param x\n * @param y\n */\nfunction makePt(x: number, y: number): Point {\n  return { x, y }\n}\n\n/**\n * Computes distance between two points\n * @param a\n * @param b\n */\nfunction distance(a: Point, b: Point): number {\n  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2))\n}\n\n/**\n * Abstracts a Rectangle and adds geometric utilities\n */\nclass Rectangle {\n  static get empty(): Rectangle {\n    return new Rectangle(0, 0, 0, 0)\n  }\n\n  static fromRect(r: Rect): Rectangle {\n    return new Rectangle(r.left, r.top, r.width, r.height)\n  }\n\n  static fromLTRB(left: number, top: number, right: number, bottom: number): Rectangle {\n    return new Rectangle(left, top, right - left, bottom - top)\n  }\n\n  constructor(readonly left: number, readonly top: number, readonly width: number, readonly height: number) {}\n\n  contains(p: Point): boolean {\n    return p.x >= this.left && p.x <= this.right && p.y >= this.top && p.y <= this.bottom\n  }\n\n  inflate(horizontal: number, vertical: number): Rectangle {\n    return Rectangle.fromLTRB(\n      this.left - horizontal,\n      this.top - vertical,\n      this.right + horizontal,\n      this.bottom + vertical\n    )\n  }\n\n  intersects(rectangle: Rectangle): boolean {\n    let thisX = this.left\n    let thisY = this.top\n    let thisW = this.width\n    let thisH = this.height\n    let rectX = rectangle.left\n    let rectY = rectangle.top\n    let rectW = rectangle.width\n    let rectH = rectangle.height\n    return rectX < thisX + thisW && thisX < rectX + rectW && rectY < thisY + thisH && thisY < rectY + rectH\n  }\n\n  union(r: Rectangle): Rectangle {\n    const x = [this.left, this.right, r.left, r.right]\n    const y = [this.top, this.bottom, r.top, r.bottom]\n    return Rectangle.fromLTRB(Math.min(...x), Math.min(...y), Math.max(...x), Math.max(...y))\n  }\n\n  get center(): Point {\n    return {\n      x: this.left + this.width / 2,\n      y: this.top + this.height / 2\n    }\n  }\n\n  get right(): number {\n    return this.left + this.width\n  }\n\n  get bottom(): number {\n    return this.top + this.height\n  }\n\n  get location(): Point {\n    return makePt(this.left, this.top)\n  }\n\n  get northEast(): Point {\n    return { x: this.right, y: this.top }\n  }\n\n  get southEast(): Point {\n    return { x: this.right, y: this.bottom }\n  }\n\n  get southWest(): Point {\n    return { x: this.left, y: this.bottom }\n  }\n\n  get northWest(): Point {\n    return { x: this.left, y: this.top }\n  }\n\n  get east(): Point {\n    return makePt(this.right, this.center.y)\n  }\n\n  get north(): Point {\n    return makePt(this.center.x, this.top)\n  }\n\n  get south(): Point {\n    return makePt(this.center.x, this.bottom)\n  }\n\n  get west(): Point {\n    return makePt(this.left, this.center.y)\n  }\n\n  get size(): Size {\n    return { width: this.width, height: this.height }\n  }\n}\n\n/**\n * Represents a node in a graph, whose data is a Point\n */\nclass PointNode {\n  public distance = Number.MAX_SAFE_INTEGER\n  public shortestPath: PointNode[] = []\n  public adjacentNodes: Map<PointNode, number> = new Map()\n  constructor(public data: Point) {}\n}\n\n/***\n * Represents a Graph of Point nodes\n */\nclass PointGraph {\n  private index: { [x: string]: { [y: string]: PointNode } } = {}\n\n  add(p: Point) {\n    const { x, y } = p\n    const xs = x.toString(),\n      ys = y.toString()\n\n    if (!(xs in this.index)) {\n      this.index[xs] = {}\n    }\n    if (!(ys in this.index[xs])) {\n      this.index[xs][ys] = new PointNode(p)\n    }\n  }\n\n  private getLowestDistanceNode(unsettledNodes: Set<PointNode>): PointNode {\n    let lowestDistanceNode: PointNode | null = null\n    let lowestDistance = Number.MAX_SAFE_INTEGER\n    for (const node of unsettledNodes) {\n      const nodeDistance = node.distance\n      if (nodeDistance < lowestDistance) {\n        lowestDistance = nodeDistance\n        lowestDistanceNode = node\n      }\n    }\n    return lowestDistanceNode!\n  }\n\n  private inferPathDirection(node: PointNode): Direction | null {\n    if (node.shortestPath.length == 0) {\n      return null\n    }\n\n    return this.directionOfNodes(node.shortestPath[node.shortestPath.length - 1], node)\n  }\n\n  calculateShortestPathFromSource(graph: PointGraph, source: PointNode): PointGraph {\n    source.distance = 0\n\n    const settledNodes: Set<PointNode> = new Set()\n    const unsettledNodes: Set<PointNode> = new Set()\n\n    unsettledNodes.add(source)\n\n    while (unsettledNodes.size != 0) {\n      const currentNode = this.getLowestDistanceNode(unsettledNodes)\n      unsettledNodes.delete(currentNode)\n\n      for (const [adjacentNode, edgeWeight] of currentNode.adjacentNodes) {\n        if (!settledNodes.has(adjacentNode)) {\n          this.calculateMinimumDistance(adjacentNode, edgeWeight, currentNode)\n          unsettledNodes.add(adjacentNode)\n        }\n      }\n      settledNodes.add(currentNode)\n    }\n\n    return graph\n  }\n\n  private calculateMinimumDistance(evaluationNode: PointNode, edgeWeigh: number, sourceNode: PointNode) {\n    const sourceDistance = sourceNode.distance\n    const comingDirection = this.inferPathDirection(sourceNode)\n    const goingDirection = this.directionOfNodes(sourceNode, evaluationNode)\n    const changingDirection = comingDirection && goingDirection && comingDirection != goingDirection\n    const extraWeigh = changingDirection ? Math.pow(edgeWeigh + 1, 2) : 0\n\n    if (sourceDistance + edgeWeigh + extraWeigh < evaluationNode.distance) {\n      evaluationNode.distance = sourceDistance + edgeWeigh + extraWeigh\n      const shortestPath: PointNode[] = [...sourceNode.shortestPath]\n      shortestPath.push(sourceNode)\n      evaluationNode.shortestPath = shortestPath\n    }\n  }\n\n  private directionOf(a: Point, b: Point): Direction | null {\n    if (a.x === b.x) {\n      return 'h'\n    } else if (a.y === b.y) {\n      return 'v'\n    } else {\n      return null\n    }\n  }\n\n  private directionOfNodes(a: PointNode, b: PointNode): Direction | null {\n    return this.directionOf(a.data, b.data)\n  }\n\n  connect(a: Point, b: Point) {\n    const nodeA = this.get(a)\n    const nodeB = this.get(b)\n\n    if (!nodeA || !nodeB) {\n      throw new Error(`A point was not found`)\n    }\n\n    nodeA.adjacentNodes.set(nodeB, distance(a, b))\n  }\n\n  has(p: Point): boolean {\n    const { x, y } = p\n    const xs = x.toString(),\n      ys = y.toString()\n    return xs in this.index && ys in this.index[xs]\n  }\n\n  get(p: Point): PointNode | null {\n    const { x, y } = p\n    const xs = x.toString(),\n      ys = y.toString()\n\n    if (xs in this.index && ys in this.index[xs]) {\n      return this.index[xs][ys]\n    }\n\n    return null\n  }\n}\n\n/**\n * Gets the actual point of the connector based on the distance parameter\n * @param p\n */\nfunction computePt(p: ConnectorPoint): Point {\n  const b = Rectangle.fromRect(p.shape)\n  switch (p.side) {\n    case 'bottom':\n      return makePt(b.left + b.width * p.distance, b.bottom)\n    case 'top':\n      return makePt(b.left + b.width * p.distance, b.top)\n    case 'left':\n      return makePt(b.left, b.top + b.height * p.distance)\n    case 'right':\n      return makePt(b.right, b.top + b.height * p.distance)\n  }\n}\n\n/**\n * Extrudes the connector point by margin depending on it's side\n * @param cp\n * @param margin\n */\nfunction extrudeCp(cp: ConnectorPoint, margin: number): Point {\n  const { x, y } = computePt(cp)\n  switch (cp.side) {\n    case 'top':\n      return makePt(x, y - margin)\n    case 'right':\n      return makePt(x + margin, y)\n    case 'bottom':\n      return makePt(x, y + margin)\n    case 'left':\n      return makePt(x - margin, y)\n  }\n}\n\n/**\n * Returns flag indicating if the side belongs on a vertical axis\n * @param side\n */\nfunction isVerticalSide(side: Side): boolean {\n  return side == 'top' || side == 'bottom'\n}\n\n/**\n * Creates a grid of rectangles from the specified set of rulers, contained on the specified bounds\n * @param verticals\n * @param horizontals\n * @param bounds\n */\nfunction rulersToGrid(verticals: number[], horizontals: number[], bounds: Rectangle): Grid {\n  const result: Grid = new Grid()\n\n  verticals.sort((a, b) => a - b)\n  horizontals.sort((a, b) => a - b)\n\n  let lastX = bounds.left\n  let lastY = bounds.top\n  let column = 0\n  let row = 0\n\n  for (const y of horizontals) {\n    for (const x of verticals) {\n      result.set(row, column++, Rectangle.fromLTRB(lastX, lastY, x, y))\n      lastX = x\n    }\n\n    // Last cell of the row\n    result.set(row, column, Rectangle.fromLTRB(lastX, lastY, bounds.right, y))\n    lastX = bounds.left\n    lastY = y\n    column = 0\n    row++\n  }\n\n  lastX = bounds.left\n\n  // Last fow of cells\n  for (const x of verticals) {\n    result.set(row, column++, Rectangle.fromLTRB(lastX, lastY, x, bounds.bottom))\n    lastX = x\n  }\n\n  // Last cell of last row\n  result.set(row, column, Rectangle.fromLTRB(lastX, lastY, bounds.right, bounds.bottom))\n\n  return result\n}\n\n/**\n * Returns an array without repeated points\n * @param points\n */\nfunction reducePoints(points: Point[]): Point[] {\n  const result: Point[] = []\n  const map = new Map<number, number[]>()\n\n  points.forEach(p => {\n    const { x, y } = p\n    let arr: number[] = map.get(y) || map.set(y, []).get(y)!\n\n    if (arr.indexOf(x) < 0) {\n      arr.push(x)\n    }\n  })\n\n  for (const [y, xs] of map) {\n    for (const x of xs) {\n      result.push(makePt(x, y))\n    }\n  }\n\n  return result\n}\n\n/**\n * Returns a set of spots generated from the grid, avoiding colliding spots with specified obstacles\n * @param grid\n * @param obstacles\n */\nfunction gridToSpots(grid: Grid, obstacles: Rectangle[]): Point[] {\n  const obstacleCollision = (p: Point) => obstacles.filter(o => o.contains(p)).length > 0\n\n  const gridPoints: Point[] = []\n\n  for (const [row, data] of grid.data) {\n    const firstRow = row == 0\n    const lastRow = row == grid.rows - 1\n\n    for (const [col, r] of data) {\n      const firstCol = col == 0\n      const lastCol = col == grid.columns - 1\n      const nw = firstCol && firstRow\n      const ne = firstRow && lastCol\n      const se = lastRow && lastCol\n      const sw = lastRow && firstCol\n\n      if (nw || ne || se || sw) {\n        gridPoints.push(r.northWest, r.northEast, r.southWest, r.southEast)\n      } else if (firstRow) {\n        gridPoints.push(r.northWest, r.north, r.northEast)\n      } else if (lastRow) {\n        gridPoints.push(r.southEast, r.south, r.southWest)\n      } else if (firstCol) {\n        gridPoints.push(r.northWest, r.west, r.southWest)\n      } else if (lastCol) {\n        gridPoints.push(r.northEast, r.east, r.southEast)\n      } else {\n        gridPoints.push(r.northWest, r.north, r.northEast, r.east, r.southEast, r.south, r.southWest, r.west, r.center)\n      }\n    }\n  }\n\n  // for(const r of grid) {\n  //     gridPoints.push(\n  //         r.northWest, r.north, r.northEast, r.east,\n  //         r.southEast, r.south, r.southWest, r.west, r.center);\n  // }\n\n  // Reduce repeated points and filter out those who touch shapes\n  return reducePoints(gridPoints).filter(p => !obstacleCollision(p))\n}\n\n/**\n * Creates a graph connecting the specified points orthogonally\n * @param spots\n */\nfunction createGraph(spots: Point[]): { graph: PointGraph; connections: Line[] } {\n  const hotXs: number[] = []\n  const hotYs: number[] = []\n  const graph = new PointGraph()\n  const connections: Line[] = []\n\n  spots.forEach(p => {\n    const { x, y } = p\n    if (hotXs.indexOf(x) < 0) hotXs.push(x)\n    if (hotYs.indexOf(y) < 0) hotYs.push(y)\n    graph.add(p)\n  })\n\n  hotXs.sort((a, b) => a - b)\n  hotYs.sort((a, b) => a - b)\n\n  const inHotIndex = (p: Point): boolean => graph.has(p)\n\n  for (let i = 0; i < hotYs.length; i++) {\n    for (let j = 0; j < hotXs.length; j++) {\n      const b = makePt(hotXs[j], hotYs[i])\n\n      if (!inHotIndex(b)) continue\n\n      if (j > 0) {\n        const a = makePt(hotXs[j - 1], hotYs[i])\n\n        if (inHotIndex(a)) {\n          graph.connect(a, b)\n          graph.connect(b, a)\n          connections.push({ a, b })\n        }\n      }\n\n      if (i > 0) {\n        const a = makePt(hotXs[j], hotYs[i - 1])\n\n        if (inHotIndex(a)) {\n          graph.connect(a, b)\n          graph.connect(b, a)\n          connections.push({ a, b })\n        }\n      }\n    }\n  }\n\n  return { graph, connections }\n}\n\n/**\n * Solves the shotest path for the origin-destination path of the graph\n * @param graph\n * @param origin\n * @param destination\n */\nfunction shortestPath(graph: PointGraph, origin: Point, destination: Point): Point[] {\n  const originNode = graph.get(origin)\n  const destinationNode = graph.get(destination)\n\n  if (!originNode) {\n    throw new Error(`Origin node {${origin.x},${origin.y}} not found`)\n  }\n\n  if (!destinationNode) {\n    throw new Error(`Origin node {${origin.x},${origin.y}} not found`)\n  }\n\n  graph.calculateShortestPathFromSource(graph, originNode)\n\n  return destinationNode.shortestPath.map(n => n.data)\n}\n\n/**\n * Given two segments represented by 3 points,\n * determines if the second segment bends on an orthogonal direction or not, and which.\n *\n * @param a\n * @param b\n * @param c\n * @return Bend direction, unknown if not orthogonal or 'none' if straight line\n */\nfunction getBend(a: Point, b: Point, c: Point): BendDirection {\n  const equalX = a.x === b.x && b.x === c.x\n  const equalY = a.y === b.y && b.y === c.y\n  const segment1Horizontal = a.y === b.y\n  const segment1Vertical = a.x === b.x\n  const segment2Horizontal = b.y === c.y\n  const segment2Vertical = b.x === c.x\n\n  if (equalX || equalY) {\n    return 'none'\n  }\n\n  if (!(segment1Vertical || segment1Horizontal) || !(segment2Vertical || segment2Horizontal)) {\n    return 'unknown'\n  }\n\n  if (segment1Horizontal && segment2Vertical) {\n    return c.y > b.y ? 's' : 'n'\n  } else if (segment1Vertical && segment2Horizontal) {\n    return c.x > b.x ? 'e' : 'w'\n  }\n\n  throw new Error('Nope')\n}\n\n/**\n * Simplifies the path by removing unnecessary points, based on orthogonal pathways\n * @param points\n */\nfunction simplifyPath(points: Point[]): Point[] {\n  if (points.length <= 2) {\n    return points\n  }\n\n  const r: Point[] = [points[0]]\n  for (let i = 1; i < points.length; i++) {\n    const cur = points[i]\n\n    if (i === points.length - 1) {\n      r.push(cur)\n      break\n    }\n\n    const prev = points[i - 1]\n    const next = points[i + 1]\n    const bend = getBend(prev, cur, next)\n\n    if (bend !== 'none') {\n      r.push(cur)\n    }\n  }\n  return r\n}\n\n/**\n * Helps create the grid portion of the algorithm\n */\nclass Grid {\n  private _rows = 0\n  private _cols = 0\n\n  readonly data: Map<number, Map<number, Rectangle>> = new Map()\n\n  constructor() {}\n\n  set(row: number, column: number, rectangle: Rectangle) {\n    this._rows = Math.max(this.rows, row + 1)\n    this._cols = Math.max(this.columns, column + 1)\n\n    const rowMap: Map<number, Rectangle> = this.data.get(row) || this.data.set(row, new Map()).get(row)!\n\n    rowMap.set(column, rectangle)\n  }\n\n  get(row: number, column: number): Rectangle | null {\n    const rowMap = this.data.get(row)\n\n    if (rowMap) {\n      return rowMap.get(column) || null\n    }\n\n    return null\n  }\n\n  rectangles(): Rectangle[] {\n    const r: Rectangle[] = []\n\n    for (const [_, data] of this.data) {\n      for (const [_, rect] of data) {\n        r.push(rect)\n      }\n    }\n\n    return r\n  }\n\n  get columns(): number {\n    return this._cols\n  }\n\n  get rows(): number {\n    return this._rows\n  }\n}\n\n/**\n * Main logic wrapped in a class to hold a space for potential future functionallity\n */\nexport class OrthogonalConnector {\n  static readonly byproduct: OrthogonalConnectorByproduct = {\n    hRulers: [],\n    vRulers: [],\n    spots: [],\n    grid: [],\n    connections: []\n  }\n\n  static route(opts: OrthogonalConnectorOpts): Point[] {\n    const { pointA, pointB, globalBoundsMargin } = opts\n    const spots: Point[] = []\n    const verticals: number[] = []\n    const horizontals: number[] = []\n    const sideA = pointA.side,\n      sideAVertical = isVerticalSide(sideA)\n    const sideB = pointB.side,\n      sideBVertical = isVerticalSide(sideB)\n    const originA = computePt(pointA)\n    const originB = computePt(pointB)\n    const shapeA = Rectangle.fromRect(pointA.shape)\n    const shapeB = Rectangle.fromRect(pointB.shape)\n    const bigBounds = Rectangle.fromRect(opts.globalBounds)\n    let shapeMargin = opts.shapeMargin\n    let inflatedA = shapeA.inflate(shapeMargin, shapeMargin)\n    let inflatedB = shapeB.inflate(shapeMargin, shapeMargin)\n\n    // Check bounding boxes collision\n    if (inflatedA.intersects(inflatedB)) {\n      shapeMargin = 0\n      inflatedA = shapeA\n      inflatedB = shapeB\n    }\n\n    const inflatedBounds = inflatedA.union(inflatedB).inflate(globalBoundsMargin, globalBoundsMargin)\n\n    // Curated bounds to stick to\n    const bounds = Rectangle.fromLTRB(\n      Math.max(inflatedBounds.left, bigBounds.left),\n      Math.max(inflatedBounds.top, bigBounds.top),\n      Math.min(inflatedBounds.right, bigBounds.right),\n      Math.min(inflatedBounds.bottom, bigBounds.bottom)\n    )\n\n    // Add edges to rulers\n    for (const b of [inflatedA, inflatedB]) {\n      verticals.push(b.left)\n      verticals.push(b.right)\n      horizontals.push(b.top)\n      horizontals.push(b.bottom)\n    }\n\n    // Rulers at origins of shapes\n    ;(sideAVertical ? verticals : horizontals).push(sideAVertical ? originA.x : originA.y)\n    ;(sideBVertical ? verticals : horizontals).push(sideBVertical ? originB.x : originB.y)\n\n    // Points of shape antennas\n    for (const connectorPt of [pointA, pointB]) {\n      const p = computePt(connectorPt)\n      const add = (dx: number, dy: number) => spots.push(makePt(p.x + dx, p.y + dy))\n\n      switch (connectorPt.side) {\n        case 'top':\n          add(0, -shapeMargin)\n          break\n        case 'right':\n          add(shapeMargin, 0)\n          break\n        case 'bottom':\n          add(0, shapeMargin)\n          break\n        case 'left':\n          add(-shapeMargin, 0)\n          break\n      }\n    }\n\n    // Sort rulers\n    verticals.sort((a, b) => a - b)\n    horizontals.sort((a, b) => a - b)\n\n    // Create grid\n    const grid = rulersToGrid(verticals, horizontals, bounds)\n    const gridPoints = gridToSpots(grid, [inflatedA, inflatedB])\n\n    // Add to spots\n    spots.push(...gridPoints)\n\n    // Create graph\n    const { graph, connections } = createGraph(spots)\n\n    // Origin and destination by extruding antennas\n    const origin = extrudeCp(pointA, shapeMargin)\n    const destination = extrudeCp(pointB, shapeMargin)\n\n    const start = computePt(pointA)\n    const end = computePt(pointB)\n\n    this.byproduct.spots = spots\n    this.byproduct.vRulers = verticals\n    this.byproduct.hRulers = horizontals\n    this.byproduct.grid = grid.rectangles()\n    this.byproduct.connections = connections\n\n    const path = shortestPath(graph, origin, destination)\n\n    if (path.length > 0) {\n      return simplifyPath([start, ...shortestPath(graph, origin, destination), end])\n    } else {\n      return []\n    }\n  }\n}\n"]}